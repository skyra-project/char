// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// https://github.com/dotnet/runtime/blob/master/src/libraries/System.Runtime/tests/System/CharTests.cs

import { fromCode, UnicodeCategory } from '../../src';

const kLatinTestSet = [
	[0x0047, 0x004c, 0x0051, 0x0056, 0x00c0, 0x00c5, 0x00ca, 0x00cf, 0x00d4, 0x00da], // UnicodeCategory.UppercaseLetter
	[0x0062, 0x0068, 0x006e, 0x0074, 0x007a, 0x00e1, 0x00e7, 0x00ed, 0x00f3, 0x00fa], // UnicodeCategory.LowercaseLetter
	[], // UnicodeCategory.TitlecaseLetter
	[], // UnicodeCategory.ModifierLetter
	[], // UnicodeCategory.OtherLetter
	[], // UnicodeCategory.NonSpacingMark
	[], // UnicodeCategory.SpacingCombiningMark
	[], // UnicodeCategory.EnclosingMark
	[0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039], // UnicodeCategory.DecimalDigitNumber
	[], // UnicodeCategory.LetterNumber
	[0x00b2, 0x00b3, 0x00b9, 0x00bc, 0x00bd, 0x00be], // UnicodeCategory.OtherNumber
	[0x0020, 0x00a0], // UnicodeCategory.SpaceSeparator
	[], // UnicodeCategory.LineSeparator
	[], // UnicodeCategory.ParagraphSeparator
	[0x0005, 0x000b, 0x0011, 0x0017, 0x001d, 0x0082, 0x0085, 0x008e, 0x0094, 0x009a], // UnicodeCategory.Control
	[], // UnicodeCategory.Format
	[], // UnicodeCategory.Surrogate
	[], // UnicodeCategory.PrivateUse
	[0x005f], // UnicodeCategory.ConnectorPunctuation
	[0x002d, 0x00ad], // UnicodeCategory.DashPunctuation
	[0x0028, 0x005b, 0x007b], // UnicodeCategory.OpenPunctuation
	[0x0029, 0x005d, 0x007d], // UnicodeCategory.ClosePunctuation
	[0x00ab], // UnicodeCategory.InitialQuotePunctuation
	[0x00bb], // UnicodeCategory.FinalQuotePunctuation
	[0x002e, 0x002f, 0x003a, 0x003b, 0x003f, 0x0040, 0x005c, 0x00a1, 0x00b7, 0x00bf], // UnicodeCategory.OtherPunctuation
	[0x002b, 0x003c, 0x003d, 0x003e, 0x007c, 0x007e, 0x00ac, 0x00b1, 0x00d7, 0x00f7], // UnicodeCategory.MathSymbol
	[0x0024, 0x00a2, 0x00a3, 0x00a4, 0x00a5], // UnicodeCategory.CurrencySymbol
	[0x005e, 0x0060, 0x00a8, 0x00af, 0x00b4, 0x00b8], // UnicodeCategory.ModifierSymbol
	[0x00a6, 0x00a7, 0x00a9, 0x00ae, 0x00b0, 0x00b6], // UnicodeCategory.OtherSymbol
	[] // UnicodeCategory.OtherNotAssigned
];

const kUnicodeTestSet = [
	[0x0102, 0x01ac, 0x0392, 0x0428, 0x0508, 0x10c4, 0x1eb4, 0x1fba, 0x2c28, 0xa668], // UnicodeCategory.UppercaseLetter
	[0x0107, 0x012d, 0x0140, 0x0151, 0x013a, 0x01a1, 0x01f9, 0x022d, 0x1e09, 0xff45], // UnicodeCategory.LowercaseLetter
	[0x01c8, 0x1f88, 0x1f8b, 0x1f8e, 0x1f99, 0x1f9c, 0x1f9f, 0x1faa, 0x1fad, 0x1fbc], // UnicodeCategory.TitlecaseLetter
	[0x02b7, 0x02cd, 0x07f4, 0x1d2f, 0x1d41, 0x1d53, 0x1d9d, 0x1daf, 0x2091, 0x30fe], // UnicodeCategory.ModifierLetter
	[0x01c0, 0x37be, 0x4970, 0x5b6c, 0x6d1e, 0x7ed0, 0x9082, 0xa271, 0xb985, 0xcb37], // UnicodeCategory.OtherLetter
	[0x0303, 0x034e, 0x05b5, 0x0738, 0x0a4d, 0x0e49, 0x0fad, 0x180b, 0x1dd5, 0x2dfd], // UnicodeCategory.NonSpacingMark
	[0x0982, 0x0b03, 0x0c41, 0x0d40, 0x0df3, 0x1083, 0x1925, 0x1b44, 0xa8b5], // UnicodeCategory.SpacingCombiningMark
	[0x20dd, 0x20de, 0x20df, 0x20e0, 0x20e2, 0x20e3, 0x20e4, 0xa670, 0xa671, 0xa672], // UnicodeCategory.EnclosingMark
	[0x0660, 0x0966, 0x0ae6, 0x0c66, 0x0e50, 0x1040, 0x1810, 0x1b50, 0x1c50, 0xa900], // UnicodeCategory.DecimalDigitNumber
	[0x2162, 0x2167, 0x216c, 0x2171, 0x2176, 0x217b, 0x2180, 0x2187, 0x3023, 0x3028], // UnicodeCategory.LetterNumber
	[0x0c78, 0x136b, 0x17f7, 0x2158, 0x2471, 0x248a, 0x24f1, 0x2780, 0x3220, 0x3280], // UnicodeCategory.OtherNumber
	[0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a, 0x202f, 0x205f, 0x3000], // UnicodeCategory.SpaceSeparator
	[0x2028], // UnicodeCategory.LineSeparator
	[0x2029], // UnicodeCategory.ParagraphSeparator
	[], // UnicodeCategory.Control
	[0x0603, 0x17b4, 0x200c, 0x200f, 0x202c, 0x2060, 0x2063, 0x206b, 0x206e, 0xfff9], // UnicodeCategory.Format
	[0xd808, 0xd8d4, 0xd9a0, 0xda6c, 0xdb38, 0xdc04, 0xdcd0, 0xdd9c, 0xde68, 0xdf34], // UnicodeCategory.Surrogate
	[0xe000, 0xe280, 0xe500, 0xe780, 0xea00, 0xec80, 0xef00, 0xf180, 0xf400, 0xf680], // UnicodeCategory.PrivateUse
	[0x203f, 0x2040, 0x2054, 0xfe33, 0xfe34, 0xfe4d, 0xfe4e, 0xfe4f, 0xff3f], // UnicodeCategory.ConnectorPunctuation
	[0x2e17, 0x2e1a, 0x301c, 0x3030, 0x30a0, 0xfe31, 0xfe32, 0xfe58, 0xfe63, 0xff0d], // UnicodeCategory.DashPunctuation
	[0x2768, 0x2774, 0x27ee, 0x298d, 0x29d8, 0x2e28, 0x3014, 0xfe17, 0xfe3f, 0xfe5d], // UnicodeCategory.OpenPunctuation
	[0x276b, 0x27c6, 0x2984, 0x2990, 0x29db, 0x3009, 0x3017, 0xfe18, 0xfe40, 0xfe5e], // UnicodeCategory.ClosePunctuation
	[0x201b, 0x201c, 0x201f, 0x2039, 0x2e02, 0x2e04, 0x2e09, 0x2e0c, 0x2e1c, 0x2e20], // UnicodeCategory.InitialQuotePunctuation
	[0x2019, 0x201d, 0x203a, 0x2e03, 0x2e05, 0x2e0a, 0x2e0d, 0x2e1d, 0x2e21], // UnicodeCategory.FinalQuotePunctuation
	[0x0589, 0x0709, 0x0f10, 0x16ec, 0x1b5b, 0x2034, 0x2058, 0x2e16, 0xa8cf, 0xfe55], // UnicodeCategory.OtherPunctuation
	[0x2052, 0x2234, 0x2290, 0x22ec, 0x27dd, 0x2943, 0x29b5, 0x2a17, 0x2a73, 0x2acf], // UnicodeCategory.MathSymbol
	[0x17db, 0x20a2, 0x20a5, 0x20a8, 0x20ab, 0x20ae, 0x20b1, 0x20b4, 0xfe69, 0xffe1], // UnicodeCategory.CurrencySymbol
	[0x02c5, 0x02da, 0x02e8, 0x02f3, 0x02fc, 0x1fc0, 0x1fee, 0xa703, 0xa70c, 0xa715], // UnicodeCategory.ModifierSymbol
	[0x0bf3, 0x2316, 0x24ac, 0x25b2, 0x26af, 0x285c, 0x2e8f, 0x2f8c, 0x3292, 0x3392], // UnicodeCategory.OtherSymbol
	[0x09c6, 0x0dfa, 0x2e5c] // UnicodeCategory.OtherNotAssigned
];

export function* getTestCharsNotInCategory(...categories: UnicodeCategory[]) {
	for (let i = 0; i < kLatinTestSet.length; i++) {
		if (categories.includes(i)) continue;

		yield* kLatinTestSet[i];
		yield* kUnicodeTestSet[i];
	}
}

export function* getTestChars(...categories: UnicodeCategory[]) {
	for (const category of categories) {
		const latinSet = kLatinTestSet[category];
		for (const latin of latinSet) {
			if (shouldTestCasingForChar(latin, category)) yield latin;
		}

		const unicodeSet = kUnicodeTestSet[category];
		for (const unicode of unicodeSet) {
			if (shouldTestCasingForChar(unicode, category)) yield unicode;
		}
	}
}

const [lowerCaseA, upperCaseA, lowerCaseZ, upperCaseZ] = 'aAzZ'.split('').map((char) => char.charCodeAt(0));
export function shouldTestCasingForChar(code: number, category: UnicodeCategory) {
	return (
		(category !== UnicodeCategory.UppercaseLetter && category !== UnicodeCategory.LowercaseLetter) ||
		(code >= lowerCaseA && code <= lowerCaseZ) ||
		(code >= upperCaseA && code <= upperCaseZ)
	);
}

export function display(code: number) {
	return `["${fromCode(code)}" 0x${code.toString(16).padStart(4, '0')}]`;
}
